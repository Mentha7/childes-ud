\chapter{Validation and Comparison} % Main chapter title

\label{Chapter5} % For referencing the chapter elsewhere, use \ref{Chapter5}

\section{Validating CHAT using CLAN Tools}

After using chatconllu to convert the conllu files back to CHAT format, the user may want to validate that the resulting cha files are well-formed and accepted by the CLAN program. CLAN has a CHECK program \sidenote{CLAN can be downloaded via \url{https://dali.talkbank.org/clan/}} that validates the CHAT transcription format. Alternatively, if the user wants to stick to the command line, they can download Chatter \sidenote{Chatter - CHAT format validator: \url{https://talkbank.org/software/chatter.html}}, a Java program from TalkBank.

% include a use case.

For the chosen corpora, CHAT files produced by chatconllu pass the CHECK program in CLAN but not Chatter for the reason of line-wrapping. Long lines in the original cha files generated from the CLAN program are broken after a certain amount of characters is reached. Continuations of the line are preceded by an initial tab. However, the current version of chatconllu does not handle the maximum length of a line, and because of that, it fails the Chatter validation process.

The differences between the original and back-converted cha files can be visually inspected using \emph{icdiff}. With this command, a side-by-side display of the two cha files selected is displayed in the terminal, with the differences coloured.

\section{Validating CoNLL-U using UD Tools}

UD also provides tools for format validation. One of the UD maintained tools is the script \emph{validate.py} \sidenote{link to file on GitHub: \url{https://github.com/UniversalDependencies/tools/blob/master/validate.py}}. However, what's tricky about UD format validation is that this script also validates the accepted values of each language in UD. To run the script, one has to input a language code. Although there are five levels of validation, the conllu files generated by the current version of chatconllu only pass the first two levels, which does not check if the values are accepted by UD or specifications of the given language.

\section{Related Work}

\paragraph{pyconll} % (fold)
\label{par:pyconll}
\emph{pyconll} (\cite{pyconll}) is a low-level API for processing CoNLL-U formatted files. In this thesis, I used pyconll for parsing the converted conllu files and especially for reading the values of individual fields.

% \paragraph{CHAT2CONLLU and CONLL2CHAT} % (fold)
% \label{par:chat2conllu}
% \emph{CHAT2CONLL} and \emph{CONLL2CHAT} are officially part of the CLAN program that transforms CHAT files to CoNLL formats.

\paragraph{Dependency Parsing for Low-resource Spontaneous Speech} % (fold)
\label{par:zoey}
(\cite{liu2021}) used a low-resource setting, focusing on one child from the Brown Corpus (\cite{brown1973}) and tested the performance of dependency parsers on parent-child conversations. The out-domain parser was trained on written text and performed well on adult speech but not so well on child speech, while the parser trained on a limited amount of in-domain spoken data improved the parsing result of child speech to be comparable with adult speech. As part of their study, they created a semi-automatic adaptation of annotation formats from CHILDES to UD.

\paragraph{The AnnCor CHILDES Treebank}
(\cite{odijk2018anncor}) preprocessed the Dutch CHILDES corpora, augmented them with syntactic annotations using the Alpino parser, and performed partial manual verification. While creating this treebank, they noticed the many disadvantages of annotation discrepancies and argued that annotation guidelines should be explicit and should be strictly followed to produce consistency. They suggest combining human annotations with automatic checks by computer programs. They also pointed out that although the grammar used in child speech is limited since the child is still acquiring the language, assigning adult syntactic structures to their utterances is still valid.
